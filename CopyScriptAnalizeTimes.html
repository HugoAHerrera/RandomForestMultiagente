<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Pruebas de lectura CSV</title>
</head>
<body>
  <h2>Seleccion√° un CSV grande</h2>
  <input type="file" id="csvFile" accept=".csv" /><br /><br />

  <button onclick="runAll()">Ejecutar todas las opciones secuencialmente</button>

  <script>
    const bestTimes = {
      opcion1: Infinity,
      opcion2: Infinity,
      opcion3: Infinity,
      opcion4: Infinity,
    };

    function guardarArchivoSimulado(nombre, contenido) {
      const blob = new Blob([contenido], { type: "text/plain" });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = nombre;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    async function opcion1() {
      const file = document.getElementById("csvFile").files[0];
      if (!file) return alert("Sub√≠ un archivo primero.");

      let chunkSize = 500000;
      const incremento = 512 * 1024;
      let mejorTiempo = bestTimes.opcion1;

      while (true) {
        let offset = 0;
        let count = 0;
        let leftover = "";
        const start = performance.now();

        async function leer() {
          return new Promise((resolve, reject) => {
            function readChunk() {
              if (offset >= file.size) {
                const end = performance.now();
                const duracion = end - start;
                console.log(
                  `Opci√≥n 1 chunkSize ${chunkSize} - ‚úÖ Lectura completada en ${duracion.toFixed(2)} ms`
                );

                if (duracion < mejorTiempo) {
                  mejorTiempo = duracion;
                  bestTimes.opcion1 = mejorTiempo;
                }

                // Guardar chunkSize y tiempo
                const contenido = `chunkSize: ${chunkSize}\ntiempo_ms: ${duracion.toFixed(2)}`;
                guardarArchivoSimulado(`opcion1_chunk${chunkSize}.txt`, contenido);

                resolve(duracion);
                return;
              }

              const slice = file.slice(offset, offset + chunkSize);
              const reader = new FileReader();

              reader.onload = function (e) {
                let text = leftover + e.target.result;
                let lines = text.split(/\r?\n/);
                leftover = lines.pop();

                for (let i = 0; i < lines.length; i++) {
                  count++;
                  if (count % 10000 === 0) {
                    console.log(
                      `Opci√≥n 1 chunkSize ${chunkSize} - üü® Simulando env√≠o de 10k l√≠neas (total: ${count})`
                    );
                  }
                }

                offset += chunkSize;
                console.log(`Opci√≥n 1 chunkSize ${chunkSize} - üì¶ Procesado hasta byte ${offset}...`);
                setTimeout(readChunk, 0);
              };

              reader.onerror = function (e) {
                console.error("‚ùå Error leyendo archivo:", e);
                reject(e);
              };

              reader.readAsText(slice);
            }
            readChunk();
          });
        }

        const tiempo = await leer();

        if (tiempo > mejorTiempo * 2) break;

        chunkSize += incremento;
      }
      return true;
    }

    async function opcion2() {
      const file = document.getElementById("csvFile").files[0];
      if (!file) return alert("Sub√≠ un archivo primero.");

      let chunkSize = 500000;
      const incremento = 512 * 1024;
      let numWorkers = 1;
      const maxWorkers = 100;
      let mejorTiempo = bestTimes.opcion2;

      while (true) {
        let offset = 0;
        const start = performance.now();

        const workers = [];
        for (let i = 0; i < numWorkers; i++) {
          const worker = new Worker(
            URL.createObjectURL(
              new Blob(
                [
                  `
            self.onmessage = function(e) {
              const text = e.data;
              const lines = text.split(/\\r?\\n/);
              self.postMessage("done");
            }
          `,
                ],
                { type: "application/javascript" }
              )
            )
          );
          workers.push(worker);
        }

        const totalChunks = Math.ceil(file.size / chunkSize);
        let doneCount = 0;

        const promesaWorkers = new Promise((resolve, reject) => {
          workers.forEach((worker) => {
            worker.onmessage = function () {
              doneCount++;
              if (doneCount === totalChunks) resolve();
            };
            worker.onerror = reject;
          });
        });

        while (offset < file.size) {
          const chunk = file.slice(offset, offset + chunkSize);
          const reader = new FileReader();
          const currentWorker = workers[(offset / chunkSize) % numWorkers];

          await new Promise((res) => {
            reader.onload = function (e) {
              currentWorker.postMessage(e.target.result);
              console.log(
                `Opci√≥n 2 chunkSize ${chunkSize} workers ${numWorkers} - üì¶ Enviado chunk desde byte ${offset}`
              );
              res();
            };
            reader.readAsText(chunk);
          });

          offset += chunkSize;
        }

        await promesaWorkers;
        const end = performance.now();
        const duracion = end - start;
        console.log(
          `Opci√≥n 2 chunkSize ${chunkSize} workers ${numWorkers} - ‚úÖ Completada en ${duracion.toFixed(
            2
          )} ms`
        );

        if (duracion < mejorTiempo) {
          mejorTiempo = duracion;
          bestTimes.opcion2 = mejorTiempo;
        }

        const contenido = `chunkSize: ${chunkSize}\nworkers: ${numWorkers}\ntiempo_ms: ${duracion.toFixed(
          2
        )}`;
        guardarArchivoSimulado(`opcion2_chunk${chunkSize}_workers${numWorkers}.txt`, contenido);

        if (duracion > mejorTiempo * 2) break;

        if (numWorkers < maxWorkers) numWorkers++;
        chunkSize += incremento;
      }
      return true;
    }

    async function opcion3() {
      const file = document.getElementById("csvFile").files[0];
      if (!file) return alert("Sub√≠ un archivo primero.");

      let chunkSize = 500000;
      const incremento = 512 * 1024;
      let mejorTiempo = bestTimes.opcion3;

      while (true) {
        let offset = 0;
        let leftover = "";
        let batch = [];
        let currentAgentIndex = 0;
        const agents = ["http://agent1.com", "http://agent2.com", "http://agent3.com"];

        const start = performance.now();

        function sendToAgent(data, agentUrl) {
          console.log(`Opci√≥n 3 chunkSize ${chunkSize} - üöÄ Enviando ${data.length} l√≠neas a ${agentUrl}`);
        }

        async function leer() {
          return new Promise((resolve, reject) => {
            function readChunk() {
              if (offset >= file.size) {
                if (batch.length > 0) {
                  sendToAgent(batch, agents[currentAgentIndex]);
                }
                const end = performance.now();
                const duracion = end - start;
                console.log(
                  `Opci√≥n 3 chunkSize ${chunkSize} - ‚úÖ Completada en ${duracion.toFixed(2)} ms`
                );

                if (duracion < mejorTiempo) {
                  mejorTiempo = duracion;
                  bestTimes.opcion3 = mejorTiempo;
                }

                const contenido = `chunkSize: ${chunkSize}\ntiempo_ms: ${duracion.toFixed(2)}`;
                guardarArchivoSimulado(`opcion3_chunk${chunkSize}.txt`, contenido);

                resolve(duracion);
                return;
              }

              const slice = file.slice(offset, offset + chunkSize);
              const reader = new FileReader();

              reader.onload = function (e) {
                let text = leftover + e.target.result;
                let lines = text.split(/\r?\n/);
                leftover = lines.pop();

                for (let i = 0; i < lines.length; i++) {
                  batch.push(lines[i]);
                  if (batch.length === 2000) {
                    sendToAgent(batch, agents[currentAgentIndex]);
                    batch = [];
                    currentAgentIndex = (currentAgentIndex + 1) % agents.length;
                  }
                }

                offset += chunkSize;
                console.log(`Opci√≥n 3 chunkSize ${chunkSize} - üì¶ Le√≠do hasta byte ${offset}`);
                setTimeout(readChunk, 0);
              };

              reader.onerror = function (e) {
                console.error("‚ùå Error leyendo archivo:", e);
                reject(e);
              };

              reader.readAsText(slice);
            }
            readChunk();
          });
        }

        const tiempo = await leer();
        if (tiempo > mejorTiempo * 2) break;

        chunkSize += incremento;
      }
      return true;
    }

    async function opcion4() {
      const file = document.getElementById("csvFile").files[0];
      if (!file) return alert("Sub√≠ un archivo primero.");

      let chunkSize = 500000;
      const incremento = 512 * 1024;
      let mejorTiempo = bestTimes.opcion4;

      while (true) {
        const start = performance.now();
        const reader = file.stream().getReader();
        const decoder = new TextDecoder("utf-8");
        let leftover = "";
        let count = 0;

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          let chunk = decoder.decode(value, { stream: true });
          let lines = (leftover + chunk).split(/\r?\n/);
          leftover = lines.pop();

          for (let i = 0; i < lines.length; i++) {
            count++;
            if (count % 10000 === 0) {
              console.log(
                `Opci√≥n 4 chunkSize ${chunkSize} - üöÄ Simulando env√≠o de 10k l√≠neas (total: ${count})`
              );
            }
          }

          console.log(`Opci√≥n 4 chunkSize ${chunkSize} - üì¶ Procesado hasta l√≠nea ${count}`);
        }

        if (leftover) {
          count++;
          console.log(`Opci√≥n 4 chunkSize ${chunkSize} - üöÄ Enviando √∫ltima l√≠nea. Total: ${count}`);
        }

        const end = performance.now();
        const duracion = end - start;
        console.log(`Opci√≥n 4 chunkSize ${chunkSize} - ‚úÖ Completada en ${duracion.toFixed(2)} ms`);

        if (duracion < mejorTiempo) {
          mejorTiempo = duracion;
          bestTimes.opcion4 = mejorTiempo;
        }

        const contenido = `chunkSize: ${chunkSize}\ntiempo_ms: ${duracion.toFixed(2)}`;
        guardarArchivoSimulado(`opcion4_chunk${chunkSize}.txt`, contenido);

        if (duracion > mejorTiempo * 2) break;

        chunkSize += incremento;
      }
      return true;
    }

    async function runAll() {
      console.clear();
      console.log("Ejecutando opci√≥n 1...");
      await opcion1();
      console.log("Ejecutando opci√≥n 2...");
      await opcion2();
      console.log("Ejecutando opci√≥n 3...");
      await opcion3();
      console.log("Ejecutando opci√≥n 4...");
      await opcion4();
      console.log("Todas las opciones finalizadas.");
    }
  </script>
</body>
</html>
